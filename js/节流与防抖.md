# 什么是防抖和节流？有什么区别？如何实现？

## 1 防抖

触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间

思路：

  每次触发事件时都取消之前的延时调用方法

  ```JavaScript
      function debounce(fn) {
        let timeout = null; // 创建一个标记用来存放定时器的返回值
        return function () {
          clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
          timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
            fn.apply(this, arguments);
          }, 500);
        };
      }
  ```

2 节流

高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率

思路：

每次触发事件时都判断当前是否有等待执行的延时函数

  <pre>
  function throttle(fn, delay) {
    let flag = true, // // 通过闭包保存一个标记
    timer = null;
    return function (...args) {
      let context = this;
      if (!flag) return; // 在函数开头判断标记是否为true，不为true则return
      flag = false; // 立即设置为false
      clearTimeout(timer)
      timer = setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
        fn.apply(context, args);
        // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
        flag = true;
      }, delay);
    };
  };
  </pre>

####适合应用场景
防抖
+ search搜索，用户不断输入值时，用防抖来节约Ajax请求,也就是输入框事件。
+ window触发resize时，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
节流
+ 鼠标的点击事件，比如mousedown只触发一次
+ 监听滚动事件，比如是否滑到底部自动加载更多，用throttle判断
+ 比如游戏中发射子弹的频率(1秒发射一颗)


